<html>
  <head>
    <link rel="stylesheet" type="text/css" href="bitstream.css" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <link rel="stylesheet" type="text/css" href="hl/style.css" />
    <script type="text/javascript" src="hl/hl-all.js"></script>
    <title>Helios Kernel - simple javascript module loader</title>
  </head>

    <body onload="DlHighlight.HELPERS.highlightByName('code', 'pre')">




<table class="pad" cellspacing=0 cellpadding=0 border=0>
  <tr>
    <td>
      <img src="logo_new.png" width=32 height=32/>
    </td>
    <td>
      <h1>Helios Kernel</h1>
    </td>
  </tr>
</table>




      <p class="download">
        <a href="https://github.com/asvd/helios-kernel/releases/download/v0.9.5/helios-kernel-0.9.5.tar.gz">helios-kernel-0.9.5.tar.gz</a>
        12&nbsp;kb
        <br/>
        <a href="https://github.com/asvd/helios-kernel">https://github.com/asvd/helios-kernel</a>
      </p>
<p>
Helios Kernel is a javascript module loader and dependency manager
with a simple module format compatible between browser-based
environment and <a href="http://nodejs.org/">Node.js</a> without any
conversion. Helios Kernel tracks the dependency graph, loads and
unloads corresponding modules dynamically in the runtime according to
the needs of different and independent parts of an application. It is
smart enough to start initializing the modules which are ready for
that, while others are still being downloaded or parsed, and to handle
some tricky problems such as circular dependencies or broken code
(reporting the problem, but still keeping the application alive). But
the key feature of Helios Kernel is
</p>

<h2>Simplicity</h2>

<p>
Following
the <a href="http://en.wikipedia.org/wiki/KISS_principle">KISS
principle</a>, Helios Kernel contains the necessary features intended
to make dependency management easy and flexible.
</p>

<p>
Syntax of a module and dependency declaration is simple and
straightforward, it is implimented in a classic include-style:
</p>

<pre name="code" class="js">// list of dependencies
include("path/to/myLibrary.js");
include("../path/to/anotherLibrary.js");

init = function() {
    // module code,
    // objects declared in the included modules are available at this point
    myLibrary.sayHello();
}
</pre>

<p>
A set of dependencies is listed in the module head using the
<span class=inline_code>include()</span> function, each call stands
for a single dependency.  The only argument is the exact path to the
source of the needed module &mdash; so that it is always easy to find out
the particular dependency source locaiton.
</p>


<p>
Module code is located inisde
the <span class=inline_code>init()</span> function declaration.  It
will be issued by Helios Kernel as soon as all dependencies are
loaded.
</p>

<p>
This is how <span class=inline_code>myLibrary.js</span> included in
the module above could look:
</p>

<pre name="code" class="js">init = function() {
    // (globally) declaring a library object
    myLibrary = {};

    // library method
    myLibrary.sayHello = function() {
        console.log("Hello World!");
    }
}
</pre>


<span class=inline_code></span>

<p>
In this example, the <span class=inline_code>init()</span> function
declares a global object. This way of exproting data is considered
unsafe sometimes, since it could lead to data collision.  But in this
text such approach is used because of its simplicity. Helios Kernel
does not force a specific way of exporting:
<span class=inline_code>init()</span> function may contain any code
you prefer. Particulary it could declare a factory function safely
returning a library object. (But if you only need to keep some private
module data, you may use the <span class=inline_code>init()</span>
function scope)
</p>

<p>
This is basicly everything you need to know to start using Helios
Kernel for setting-up dependencies in your project.
</p>

<p>
This text contains the full documentation on Helios Kernel.
</p>

<h2>How can Kernel be useful for browser-based applications</h2>

<p>
In the browser environments there is no native dependency management
solution. To ensure that a set of javascript-libraries is loaded, the
libraries are usually listed within a single html-page
header. Managing the dependencies and loading order is too tricky in
this case, and gets more and more complicated along with the project
growth.
</p>

<p>
To solve this problem, several script loading approaches and libraries
exist, one of which is Helios Kernel. This library may be preferred in
case when there is a need to create an application which will be
compatible between web environment and Node.js without any conversion.
One may also choose Helios Kernel because of its simplicity. Comparing
to other approaches which seem a bit overdesigned sometimes, with
Helios Kernel it could be more convenient to:
</p>

<ul>
  <li>
modify or refactor a list of dependencies, especially when are a lot
of them (each dependency is just a
single <span class=inline_code>include()</span> line at the module
head)
  </li>
  <li>
create a compound module which should load several modules used at
once (in Helios Kernel such module could simply list all dependencies
using <span class=inline_code>include()</span>, without the need to
transfer other modules' routines through the exported objects)
  </li>
  <li>
reuse "ordinary" javascript libraries designed to be loaded using
the <span class=inline_code>&lt;script&gt;</span> tag in a
html-page. Helios Kernel module format is very simple, so such library
could be easily converted to a module by wrapping its code with an
<span class=inline_code>init()</span> function declaration.
  </li>
</ul>


<h2>How can Kernel be useful for Node.js applications</h2>

<p>
In Node.js there is a native dependency declaration technique &mdash; the
<span class=inline_code>require()</span> function which implements the
specifications suggested by
the <a href="http://en.wikipedia.org/wiki/CommonJS">CommonJS</a>
group.
</p>

<p>
Helios Kernel API pretends to be a simplier and more flexible
alternative to the CommonJS specifications.
</p>

<h3>What is simplier:</h3>


<ul>
  <li>
 It is easier to see and declare module's dependencies (they are
  always listed in the module head, not inside its body, not in some
  external config)
  </li>

  <li>
 There could be no 'hidden' dependencies declared in the middle of a
  code (dynamically loading additional modules is a different use-case
  which is performed by the <span class=inline_code>kernel.require()</span> function)
  </li>

  <li>
 It is easier to find out where the particular dependency source code
  is located (dependencies are always declared by exact path)
  </li>

  <li>
 Module structure, documentation and usage are simplier (there is no
  need to declare a special export object and reuse it in the
  dependent modules, instead library objects are exported using the
  global scope, and they are always referred with the same name)
  </li>

  <li>
 Circular dependencies considered as an error (which prevents
  dependency mess-up and helps to keep everything in order)
  </li>

  <li>
 It is easier to split the library objects between the different
  modules (since there is no export object, it is easier to create a
  compound library module which will simply include all library
  modules each making up some part of the library)
  </li>
</ul>




<h3>What is more flexible:</h3>

  <ul>
    <li>
 It is possible to unload the code which is not needed anymore
   </li>

   <li>
 Any javascript library could be easily converted to the Helios
 Kernel module &mdash; in most cases its code should simply be wrapped with
 an <span class=inline_code>init()</span> function declaration
   </li>

   <li>
 Helios Kernel modules format is cross-compatible between browser and
 Node.js enviroment, therefore it is possible to create a library which
 will work unchanged under both environments (of course until there is
 some specific platform-dependent code)
    </li>
  </ul>

<h2>How to setup a new project based on the Helios Kernel</h2>

  <ol>
    <li>
Download the distribution
<a href="https://github.com/asvd/helios-kernel/releases/download/v0.9.5/helios-kernel-0.9.5.tar.gz">here</a>
and unpack it somwhere, i.e. in <span class=inline_code>helios-kernel/</span> directory. You may
also use <a href="https://npmjs.org/">npm</a> to install Helios Kernel under
Node.js:

<pre name="code" class="js">$ npm install helios-kernel
</pre>
   </li>

   <li>
Create the initial module for the project, i.e. <span class=inline_code>main.js</span> with the
following content:

<pre name="code" class="js">// include the needed libraries here

init = function() {
    // start your application code here
    console.log('hello world!');
}
</pre>

To declare the initial module dependencies,
use <span class=inline_code>include()</span> function at the module
head
   </li>


   <li>
Create the web-based starting point which will load Helios Kernel
source, and then require the project initial script. Web-based
starting point could be for instance <span class=inline_code>index.html</span> with the following
content:

<pre name="code" class="html">&lt;script src="helios-kernel/kernel.js"&gt;&lt;/script&gt;
&lt;script&gt;
    window.onload = function(){
        kernel.require('main.js');
    }
&lt;/script&gt;
</pre>
   </li>

   <li>
Create the Node.js starting point which will load Helios Kernel
library, and then require the project initial script. Starting point
for Node.js could be for instance <span class=inline_code>nodestart.js</span> with the following
content:

<pre name="code" class="js">require('helios-kernel/kernel.js');
kernel.require( __dirname + '/main.js');
</pre>

If you have used npm to install Helios Kernel, you may also do it like
this:

<pre name="code" class="js">require('helios-kernel');
kernel.require( __dirname + '/main.js');
</pre>
   </li>


   <li>
To launch the application under web-browser, load the newly created
<span class=inline_code>index.html</span>, or set the project directory as a web-server root. To
start the application under node, launch the newly created
<span class=inline_code>nodestart.js</span> using Node.js:

<pre name="code" class="js">$ nodejs nodestart.js
</pre>
    </li>
   </ol>


<h2>How to use Helios Kernel modules with an existing project</h2>

  <ol>
    <li>
 Download the Helios Kernel
distribution <a href="https://github.com/asvd/helios-kernel/releases/download/v0.9.5/helios-kernel-0.9.5.tar.gz">here</a> and unpack
it somwhere. For Node.js you may also use npm to install
Helios Kernel:
<pre name="code" class="js">$ npm install helios-kernel
</pre>
    </li>

    <li>
      Load the Helios Kernel library script <span class=inline_code>kernel.js</span> in the
distribution using any technique suitable for your
project/environment. For a browser-based environment you could add a
<span class=inline_code>&lt;script&gt;</span> tag to the head of HTML-document. For Node.js you could use
node's <span class=inline_code>require()</span> function to load Helios Kernel (see examples
in the previous section).
    </li>

    <li>
 After the <span class=inline_code>kernel.js</span> is loaded, you may
use <span class=inline_code>kernel.require()</span> function to load
any Kernel-compatible library.
    </li>
  </ol>

<h2>How to create a Helios Kernel module</h2>

<p>
A module code should be located inside
the <span class=inline_code>init()</span> function body which is
declared globally for each module. Above that function, a set of
dependencies are listed using
the <span class=inline_code>include()</span> function. Inside
the <span class=inline_code>init()</span> function, global objects
could be declared. These are the objects provided by the module to
other modules which include this module as a dependency.
</p>

<p>
For instance, you could have a
module <span class=inline_code>library.js</span> providing a library
function to any module which will include it:
</p>

<pre name="code" class="js">// library.js module initializer
init = function() {
    // global object containing the library routines
    myLibrary = {};

    // function provided by the library
    myLibrary.doSomething = function() {
        console.log('hello');
    }
}
</pre>

<p>
And this is how a module using that library should look like:
</p>

<pre name="code" class="js">include("path/to/library.js");

init = function() {
    // library is loaded and we can use it at this point
    myLibrary.doSomething();  // will print 'hello'
}
</pre>

<h2>Dynamical module loading</h2>

<p>
To load a module in the runtime, use <span class=inline_code>kernel.require()</span> function. It
takes three arguments &mdash; absolute path of the module, and two callbacks
&mdash; for a success and for a failure.
</p>

<p>
Unlike <span class=inline_code>include()</span> which is used for declaring a dependency in a
module head, and is mostly intended to work with relative paths,
<span class=inline_code>kernel.require()</span> only accepts specifying the absolute path. For a
web environment you may start it with the slash <span class=inline_code>/</span> which will stand
for the domain root. To load a romete module, provide the full URL
starting with a protocol (<span class=inline_code>http://...</span>). You may also provide an array
of paths to load several modules at once.
</p>

<p>
Second argument, the success callback, is a function which is called
after all demanded modules and their dependencies are successfully
loaded and initialized. Inside that callback you may start using the
objects provided by the requested modules.
</p>

<p>
Third argument is a failure callback which will be called in case if
some of the requested modules (or their dependency) has failed to be
loaded. Reasons could be very different (from syntax error and to
network problems), therefore you must implement some reasonable
fallback or cancellation behaviour for the loading failure.
</p>

<p>
The returned value of <span class=inline_code>kernel.require()</span> is a reservation ticket, a
special object corresponding to the single <span class=inline_code>require()</span> act. You will
need the ticket to unload requested modules in the future when you
don't need them anymore.
</p>

<p>
Therefore, dynamically loading a module looks like this:
</p>

<pre name="code" class="js">var sCallback = function() {
    // the library is loaded, we may use it now
    myLibrary.doSomething();
}

var fCallback = function() {
    // library failed to load, falling back
    console.log('Cannot go any further!');
}

var ticket = kernel.require(
    '/path/to/library.js', sCallback, fCallback
);
</pre>

<p>
After you have finished using the requested modules, you may release
the ticket by calling <span class=inline_code>kernel.release()</span> function:
</p>

<pre name="code" class="js">kernel.release(ticket);
</pre>

<p>
This will not make the Kernel unload the module immediately, instead
the Kernel will know that the module is not needed anymore at the area
related to the given ticket, and will unload the module after it will
be released everywhere else.
</p>

<h2>Module uninitializer</h2>

<p>
Upon the module unload, its code is removed from the Kernel module
cache. But the Kernel does not track the objects created by the
module's initializer, therefore you may provide an uninitializer
function which should remove the library objects. This function will
be called during the module unload.
</p>

<p>
Therefore the full version of a library module will look like this:
</p>

<pre name="code" class="js">// module initializer
init = function() {
    // global object containing the library routines
    myLibrary = {};

    // function provided by the library
    myLibrary.doSomething = function() {
        console.log('hello');
    }
}


// module uninitializer
uninit = function() {
    // removing objects created in initializer
    myLibrary = null;
    delete myLibrary;
}
</pre>

<p>
If a module initializer declares a single compound object containing
all the library routines inside (the recommended
way, <span class=inline_code>myLibrary</span> in the example above),
simply clearing that object should be enough, garbage collector should
(hopely) do the rest.
</p>

<h2>How to convert existing javascript library to Kernel module</h2>

<p>
If you have a library of any format, it usually defines a set of
routines which should be later used from outside. In most of the
web-libraries which are intednded to be included using
the <span class=inline_code>&lt;script&gt;</span> tag, a set of global
objects are simply defined. In this case it should be enough to wrap
the library code with the <span class=inline_code>init()</span>
function declaration. So if the original source was like this:
</p>

<pre name="code" class="js">libraryObject = {
   ...
};

libraryFunction = function() {
   ...
};
</pre>

<p>
then it should be remade like this:
</p>

<pre name="code" class="js">init = function() {
    libraryObject = {
       ...
    };

    libraryFunction = function() {
       ...
    }
}
</pre>

<p>
Now this is a Helios Kernel compatible module, and could be loaded
using <span class=inline_code>include()</span> function. If you load
this module, the code of
library's <span class=inline_code>init()</span> function will be
issued and initialize the objects before
the <span class=inline_code>init()</span> function code of the module
which requested the library.
</p>

<p>
For the libraries using some kind of export object, the whole code
should also be wrapped with the <span class=inline_code>init()</span>
function, and the export object should be declared globally. For
instance, a Node.js module usually looks like this:
</p>

<pre name="code" class="js">this.someObject = {
   ...
};

this.someFunction = function() {
   ...
};
</pre>

<p>
To be converted to the Helios module, it should be remade like this:
</p>

<pre name="code" class="js">init = function() {
    // global library object
    someLibrary = {};

    someLibrary.someObject = {
       ...
    };

    someLibrary.someFunction = function() {
       ...
    }
}
</pre>

<p>
After this module is loaded, its routines should be refered as
<span class=inline_code>someLibrary.someObject</span>.
</p>

<br/>
<br/>




<table class="pad" cellspacing=0 cellpadding=0 border=0>
  <tr>
    <td>
      <table cellspacing=0 cellpadding=0 border=0>
        <tr><td height=34><img src="cc.png" width=32 height=32/></td></tr>
        <tr><td height=32><img src="by.png" width=32 height=32/></td></tr>
      </table>
    </td>
    <td>
            <p class="copy">
            Helios Kernel library is licensed under the MIT license,
            see <a href=http://github.com/asvd/helios-kernel>http://github.com/asvd/helios-kernel</a>
            <br/>
            Content of this page is licensed under the Creative Commons Attribution 3.0 Unported License.
            <br/>
            To view a copy of this license, visit <a href=http://creativecommons.org/licenses/by/3.0/>http://creativecommons.org/licenses/by/3.0/</a>
            <br/>
            or send a letter to Creative Commons,
            <br/>
            171 Second Street, Suite 300, San Francisco, California, 94105, USA.
            </p>
    </td>
  </tr>
</table>


    
  </body>
</html>
