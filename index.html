<html>
  <head>
    <link href="favicon.ico" rel="shortcut icon" type="image/x-icon">
    <link rel="stylesheet" type="text/css" href="bitstream.css" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <link rel="stylesheet" type="text/css" href="hl/style.css" />
    <script type="text/javascript" src="hl/hl-all.js"></script>
    <title>Helios Kernel, JavaScript module loader and dependencies manager</title>
  </head>

    <body onload="DlHighlight.HELPERS.highlightByName('code', 'pre')">




<table class="pad" cellspacing=0 cellpadding=0 border=0>
  <tr>
    <td>
      <img src="logo_new.png" width=32 height=32/>
    </td>
    <td>
      <h1>Helios Kernel &mdash; include() for JavaScript</h1>
    </td>
  </tr>
</table>




      <p class="download">
        <a href="https://github.com/asvd/helios-kernel/releases/download/v0.9.6/helios-kernel-0.9.6.tar.gz">helios-kernel-0.9.6.tar.gz</a>
        13&nbsp;kb
        <br/>
        <a href="https://github.com/asvd/helios-kernel">https://github.com/asvd/helios-kernel</a>
      </p>
<p>
Helios Kernel is an isomorphic JavaScript module loader and dependency
manager. Under <i>isomorphic</i> it is implied that an application or a
library based upon the Helios Kernel can run both in browser-based
environment and in <a href="http://nodejs.org/">Node.js</a> natively
and without any kind of conversion. For the moment of writing, this is
the only module loader focused on being truly isomorphic.
</p>

<p>
Helios Kernel tracks the dependency graph, loads and unloads
corresponding modules dynamically in the runtime according to the
needs of different and independent parts of an application. It is
smart enough to start initializing the modules which are ready for
that, while others are still being downloaded or parsed, and to handle
some tricky problems such as circular dependencies or broken code
(reporting the problem, but still keeping the application alive). But
the key feature of Helios Kernel is
</p>

<a name="simplicity"><h2>Simplicity</h2></a>

<p>
Helios Kernel provides the necessary features intended
to make dependency management simple and straightforward. Syntax of a
module and dependency declaration is implimented in the classic
include-style:
</p>

<pre name="code" class="js">// list of dependencies
include('path/to/someLibrary.js');
include('../path/to/anotherLibrary.js');

init = function() {
    // module code,
    // objects declared in the included modules are available at this point
    someLibrary.sayHello();
}
</pre>

<p>
A set of dependencies is listed in the module head using the
<span class=inline_code>include()</span> function, where each call
stands for a single dependency.  The only argument is the exact path
to the source of the needed module &mdash; so that it is always easy to find
out the particular dependency source location.
</p>


<p>
Module code is located inisde
the <span class=inline_code>init()</span> function declaration.  It
will be issued by Helios Kernel as soon as all dependencies are
loaded.
</p>

<p>
This is how <span class=inline_code>someLibrary.js</span> included in
the module above could look:
</p>

<pre name="code" class="js">init = function() {
    // (globally) declaring a library object
    someLibrary = {};

    // library method
    someLibrary.sayHello = function() {
        console.log('Hello World!');
    }
}
</pre>


<p>
In this example the <span class=inline_code>someLibrary</span> object
is declared as a global.  This differs to a more common approach of
objects exporting (which is considered as a must-have nowadays and is
reused in most of other loaders), however this is done intentionally
and there are some serious reasons for that:
</p>

<p>
<i>
The exporting technique (based on
the <a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">module
pattern</a>) aims to provide the precise control over the objects
created by a library, but its disadvantage is the overheads during
managing the dependency structure introduced by an artificial coupling
between a module (library internal structure) and the exported object
(library interface). Moreover, deeper investigation shows that such
fine control over the exported
objects <a href="https://gist.github.com/asvd/7619633">does not bring
any advantages over simply declaring globals</a>.
</i>
</p>

<p>
Helios Kernel does not apply any restrictions on how to transfer the
data between the modules, even some custom exporting technique may be
implemented on top of it. However declaring an object as a global is
suggested as a simpliest method.
</p>

<p>
Thereby the <span class=inline_code>init()</span> function may contain
any preferred code, its scope may be used to keep some private data,
and to make some object available from outside, it could be declared
as a global.
</p>

<p>
This is basicly everything you need to know to start using Helios
Kernel for setting-up the dependencies in your project. This text
contains the full documentation on Helios Kernel.
</p>

<h2>Helios Kernel compared to other approaches</h2>

<p>
There is no native dependency management solution in browser
environments. To ensure that a set of JavaScript-libraries is loaded,
the libraries are usually listed within a single html-page
header. Managing the dependencies and loading order is too tricky in
this case, and gets more and more complicated along with the project
growth. To solve this problem, several script loading approaches and
libraries exist, one of which is Helios Kernel.
</p>

<p>
In Node.js there is a native dependency declaration technique &mdash; the
<span class=inline_code>require()</span> function which implements the
specifications suggested by
<a href="http://en.wikipedia.org/wiki/CommonJS">CommonJS</a>
group. Just like as in most of the browser-based solutions, it
introduces object exporting,
which <a href="https://gist.github.com/asvd/7619633">as mentioned</a>
more likely brings unnecessary complications to dependency management
and objects declaration. Therefore Helios Kernel pretends to be a
simplier and more flexible alternative.
</p>

<p>
Helios Kernel may be preferred because of its simplicity, or if there
is a need to to have the modules isomorphic and compatible between web
and Node.js environments. Comparing to other dependency-management
solutions, with Helios Kernel it could be more convenient to:
</p>

<ul>
  <li>
modify or refactor a list of dependencies, especially when there are a
lot of them (each dependency is just a
single <span class=inline_code>include()</span> line referring to a
module by its path, which is specified at the module head, not inside
the module body or even some external config)
  </li>
  <li>
create a compound module which should load several modules to be
used at once (such module could simply list all dependencies using
<span class=inline_code>include()</span>, without a need to transfer
other modules' routines through the exported objects)
  </li>
  <li>
reuse "ordinary" JavaScript libraries designed to be loaded using
the <span class=inline_code>&lt;script&gt;</span> tag in a html-page
(module format is very simple, and such a library could be easily
converted to a module by wrapping its code with
an <span class=inline_code>init()</span> function declaration)
  </li>
</ul>



 <h2>How to setup a new project based on the Helios Kernel</h2>

   <ol>
     <li>
 Download the distribution
 <a href="https://github.com/asvd/helios-kernel/releases/download/v0.9.6/helios-kernel-0.9.6.tar.gz">here</a>
 and unpack it somewhere, i.e. in <span class=inline_code>helios-kernel/</span> directory. You may
 also use <a href="https://npmjs.org/">npm</a> to install Helios Kernel under
 Node.js:

 <pre name="code" class="js">$ npm install helios-kernel
 </pre>
    </li>

    <li>
 Create the initial module for the project, i.e. <span class=inline_code>main.js</span> with the
 following content:

 <pre name="code" class="js">// include the needed libraries here

init = function() {
    // start your application code here
    console.log('Hello world!');
}
</pre>

To declare the initial module dependencies,
use <span class=inline_code>include()</span> function at the module
head
   </li>


   <li>
Create the web-based starting point which will load Helios Kernel
source, and then require the project initial script. Web-based
starting point could be for instance
an <span class=inline_code>index.html</span> with the following
content:

<pre name="code" class="html">&lt;script src="helios-kernel/kernel.js"&gt;&lt;/script&gt;
&lt;script&gt;
    window.onload = function(){
        kernel.require('main.js');
    }
&lt;/script&gt;
</pre>
   </li>

   <li>
Create the Node.js starting point which will load Helios Kernel
library, and then require the project initial script. Starting point
for Node.js could be for instance <span class=inline_code>nodestart.js</span> with the following
content:

<pre name="code" class="js">require('helios-kernel/kernel.js');
kernel.require( __dirname + '/main.js');
</pre>

If you have used <span class=inline_code>npm</span> to install Helios
Kernel, you may also do it like this:

<pre name="code" class="js">require('helios-kernel');
kernel.require( __dirname + '/main.js');
</pre>
   </li>


   <li>
To launch the application under web-browser, load the newly created
<span class=inline_code>index.html</span>, or set the project directory as a web-server root. To
start the application under node, launch the newly created
<span class=inline_code>nodestart.js</span> using Node.js:

<pre name="code" class="js">$ node nodestart.js
</pre>
    </li>
   </ol>


<h2>How to use Kernel-compatible library with an existing project</h2>

  <ol>
    <li>
 Download the Helios Kernel
distribution <a href="https://github.com/asvd/helios-kernel/releases/download/v0.9.6/helios-kernel-0.9.6.tar.gz">here</a>
and unpack it somwhere. For Node.js you may also
use <span class=inline_code>npm</span> to install Helios Kernel:
<pre name="code" class="js">$ npm install helios-kernel
</pre>
    </li>

    <li>
Load the Helios Kernel library
script <span class=inline_code>kernel.js</span> from the distribution
using any technique suitable for your project/environment. For a
browser-based environment you could add a
<span class=inline_code>&lt;script&gt;</span> tag to the head of HTML-document. For Node.js you could use
node's <span class=inline_code>require()</span> function to load Helios Kernel (see examples
in the previous section).
    </li>

    <li>
 After the <span class=inline_code>kernel.js</span> is loaded, you may
use <span class=inline_code>kernel.require()</span> function to load
any Kernel-compatible library.
    </li>
  </ol>


<p>
Optionally you can even convert and merge a Kernel-compatible library
using the <a href=http://github.com/asvd/helios-merge/>helios-merge</a>
tool into a plain JavaScript bundle suitable for using without Helios
Kernel.
</p>


<h2>How to create a Helios Kernel module</h2>

<p>
Module structure is explained in the first section of this
text. Basically a module consists of the two parts: the list of
dependencies in the module head using
the <span class=inline_code>include()</span> function, and the module
code inside the <span class=inline_code>init()</span> function
declaration:
</p>

<pre name="code" class="js">// list of dependencies
include('path/to/someLibrary.js');
include('../path/to/anotherLibrary.js');

init = function() {
    // module code,
    // objects declared in the included modules are available at this point
    someLibrary.sayHello();
}
</pre>

<p>
The simpliest approach to make the module data available to other
modules, is to (globally) declare the needed objects.
</p>

<h2>Dynamical module loading</h2>

<p>
To load a module in the runtime,
use <span class=inline_code>kernel.require()</span> function. It takes
three arguments &mdash; absolute path of the module, and the two
callbacks &mdash; for a success and for a failure.
</p>

<p>
Unlike <span class=inline_code>include()</span> which is used for declaring a dependency in a
module head, and is mostly intended to work with relative paths,
<span class=inline_code>kernel.require()</span> only accepts
specifying the absolute path. For a web environment you may start it
with the slash <span class=inline_code>/</span> which will stand for
the domain root. To load a remote module, provide the full URL
starting with a protocol
(<span class=inline_code>http://...</span>). You may also provide an
array of paths to load several modules at once.
</p>

<p>
Second argument, the success callback, is a function which is called
after all demanded modules and their dependencies are successfully
loaded and initialized. Inside this callback you may start using the
objects provided by the requested modules.
</p>

<p>
Third argument is a failure callback which will be called in case if
some of the requested modules (or their dependencies) has failed to be
loaded. Reasons could be very different (from syntax error to network
problems), therefore you must implement some reasonable fallback or
cancellation behaviour for the loading failure.
</p>

<p>
The returned value of <span class=inline_code>kernel.require()</span>
is a reservation ticket, a special object corresponding to a
single <span class=inline_code>require()</span> act. You will need the
ticket if you wish to unload the requested modules in the future when
you don't need them anymore.
</p>

<p>
Therefore, dynamically loading a module looks like this:
</p>

<pre name="code" class="js">var sCallback = function() {
    // the library is loaded, we may use it now
    someLibrary.doSomething();
}

var fCallback = function() {
    // library failed to load, falling back
    console.log('Cannot go any further!');
}

var ticket = kernel.require(
    '/path/to/library.js', sCallback, fCallback
);
</pre>

<p>
After you have finished using the requested modules, you may release
the ticket by calling <span class=inline_code>kernel.release()</span> function:
</p>

<pre name="code" class="js">kernel.release(ticket);
</pre>

<p>
This will not make the Kernel to unload the related modules
immediately, instead the Kernel will know that they are not needed
anymore at the area related to the given ticket, and will unload the
modules after they will be released everywhere else.
</p>

<h2>Module uninitializer</h2>

<p>
Upon the module unload, its code is removed from the Kernel module
cache. But Kernel does not track the objects created by the module's
initializer, therefore you may provide an uninitializer function which
would remove the library objects. This function will be called during
the module unload.
</p>

<p>
Therefore the full version of a library module could look like this:
</p>

<pre name="code" class="js">// module initializer
init = function() {
    // (globally) declaring a library object
    someLibrary = {};

    // library method
    someLibrary.sayHello = function() {
        console.log('Hello World!');
    }
}


// module uninitializer
uninit = function() {
    // removing objects created in the initializer
    someLibrary = null;
    delete someLibrary;
}
</pre>

<p>
If a module initializer declares a single compound object
encapsulating all the library routines (the recommended way,
<span class=inline_code>someLibrary</span> in the example above),
simply clearing that object should be enough, garbage collector should
(hopefully) do the rest.
</p>


<h2>How to convert an existing library to a Kernel module</h2>

<p>
If you have a library of any format, it usually defines a set of
routines which should be used from the outside later. In most of the
web-libraries which are intended to be included using
the <span class=inline_code>&lt;script&gt;</span> tag, a set of global
objects is defined. In this case it should be enough to wrap the
library code with the <span class=inline_code>init()</span> function
declaration. So if the original source was like this:
</p>

<pre name="code" class="js">libraryObject = {
   ...
};

libraryFunction = function() {
   ...
};
</pre>

<p>
then it should be remade like this:
</p>

<pre name="code" class="js">init = function() {
    libraryObject = {
       ...
    };

    libraryFunction = function() {
       ...
    }
}
</pre>

<p>
Now this is a Helios Kernel compatible module, and could be loaded
using the <span class=inline_code>include()</span> function. If you
load this module, the code of
library's <span class=inline_code>init()</span> function will be
issued and initialize the objects before
the <span class=inline_code>init()</span> function code of the module
which requested the library.
</p>

<p>
For the libraries using some kind of export object, the whole code
should also be wrapped with the <span class=inline_code>init()</span>
function. To make the exported objects, they could be globally
redeclared. For instance, a CommonJS module could looks like this:
</p>

<pre name="code" class="js">this.someObject = {
   ...
};

this.someFunction = function() {
   ...
};
</pre>

<p>
To be converted to the Helios module, it should be remade like this:
</p>

<pre name="code" class="js">init = function() {
    // global library object
    someLibrary = {};

    someLibrary.someObject = {
       ...
    };

    someLibrary.someFunction = function() {
       ...
    }
}
</pre>

<p>
After this module is loaded, its routines could be referred to as
<span class=inline_code>someLibrary.someObject</span>.
</p>

<br/>
<br/>




<table class="pad" cellspacing=0 cellpadding=0 border=0>
  <tr>
    <td>
      <table cellspacing=0 cellpadding=0 border=0>
        <tr><td height=34><img src="cc.png" width=32 height=32/></td></tr>
        <tr><td height=32><img src="by.png" width=32 height=32/></td></tr>
      </table>
    </td>
    <td>
            <p class="copy">
            Helios Kernel library is licensed under the MIT license,
            see <a href=http://github.com/asvd/helios-kernel>http://github.com/asvd/helios-kernel</a>
            <br/>
            Content of this page is licensed under the Creative Commons Attribution 3.0 Unported License.
            <br/>
            To view a copy of this license, visit <a href=http://creativecommons.org/licenses/by/3.0/>http://creativecommons.org/licenses/by/3.0/</a>
            <br/>
            or send a letter to Creative Commons,
            <br/>
            171 Second Street, Suite 300, San Francisco, California, 94105, USA.
            </p>
    </td>
  </tr>
</table>


    
  </body>
</html>
